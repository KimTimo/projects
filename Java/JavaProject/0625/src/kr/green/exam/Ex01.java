package kr.green.exam;
/*
농장 분할
밥 아저씨는 돈을 힘들게 모은 끝에 한 토지를 구입했다.
밥 아저씨는 그 토지에 유명한 식물을 심을려고 하는데,
그 식물은 주변 √n 미터 안에 다른 식물이 있으면 자라지 못한 다고 한다.
그러므로 토지의 넓이를 n으로 나누어야 한다.
토지의 가로와 세로의 길이를 입력받을때, 최대 심을 수 있는 식물의 개수는?
(단, n의 값은 식이 성립하는 n의 범위 중에서 최대여야 한다.)
예)
640  400
1980 640
답)
40
3168
단 반드시 그 나무를 중심으로 한 √n 영역이 필요하다. 그리고 그 영역이 다른 영역과 겹치면 안된다.

풀이
1. 나무를 중심으로 한 n*n 크기의 영역이 필요하다.
2. 영역이 다른 나무의 영역과 겹치지 않아야 한다.
//---------------------------------------------------------------------------------------------------
최대공약수 GCD(Greatest Common Divisor) : 두 자연수의 공통된 약수 중 가장 큰 수를 의미한다.
ex) 72 와 30의 최대공약수는 6이다.
최소공배수 LCM(Least Common Multiple) : 두 자연수의 공통된 배수 중 가장 작은 수를 의미한다.
최소공배수 = 두 자연수의 곱 / 최대공약수
ex) 72 와 30의 최소공배수는 360이다.

유클리드 호제법(Euclidean Algorithm)
2개의 자연수를 받아 최대공약수를 받기 위해 
2부터 두 자연수 중 작은 자연수까지 모두 나누어보면서 가장 큰 공약수를 구할 수 있다.

2개의 자연수  a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면 (단 a>b), 
a와 b의 최대공약수는 b와 r의 최대공약수와 같다. 
이 성질에 따라, b를 r로 나눈 나머지 r0를 구하고, 
다시 r을 r0로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다. 
이는 명시적으로 기술된 가장 오래된 알고리즘으로서도 알려져 있으며, 
기원전 300년경에 쓰인 유클리드의 <원론> 제7권, 명제 1부터 3까지에 해당한다.
//---------------------------------------------------------------------------------------------------
*/
public class Ex01 {
	public static void main(String[] args) {
		System.out.println("최대공약수 : " + gcd(72,30));
		System.out.println("최대공약수 : " + gcd2(72,30));
		System.out.println("최소공배수 : " + 72*30/gcd(72,30));
		
		int num1 = 640;
		int num2=400;
		System.out.println((num1 * num2) / (gcd(num1, num2)*gcd(num1, num2)));
		
		num1 = 1980;
		num2 = 640;
		System.out.println((num1 * num2) / (gcd(num1, num2)*gcd(num1, num2)));
	}
	// 최대 공약수(유클리드 호제법) : 재귀호출
	public static int gcd(int num1, int num2){
        if(num2 == 0) return num1;
        else return gcd(num2, num1 % num2);
    }
	// 최대 공약수(유클리드 호제법) : 일반
	private static int gcd2(int num1, int num2) {
        while (num2 != 0) {
            int temp = num1 % num2;
            num1 = num2;
            num2 = temp;
        }
        return num1;
    }
}
